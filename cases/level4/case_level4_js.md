# 难度等级4，难点或深度知识

## js解析过程

对于静态语言(Java、C++、C等)来说，有一个“编译器”，可以将写好的代码编译成另一种代码(如机器码,字节码)，
然后通过其它方法(比如汇编器转换汇编代码)将这些机器码变为机器可执行命令，这就是大致的代码运行过程。
而对于Javascript这样一种动态语言而言，有一个“解释器”，
可以直接动态解析代码，并将代码运行，输出结果。
你知道JS代码解析运行的流程么，请描述出来?

```js
如果一个文档流中包含多个Script代码段(用Script标签分隔的js代码或引入的js文件),他们的执行顺序是:

步骤1:读入第一个代码段(JS执行引擎并非一行一行的执行程序,而是一段一段的分析)
步骤2:做语法分析,有错则报语法错误(比如括号不匹配),并调到步骤5
步骤3:对var变量和function做’预解析’(先进行函数声明，而后进行变量声明（如果已经有函数声明，则变量声明无效），变量统一的默认值是undefined,)
步骤4:执行代码段(赋值也是在这个阶段),有错则报错(比如调用了null.属性就会报错)
步骤5:如果还有下一个代码段,则读入下一个代码段,重复步骤2
步骤6:结束
```

## JS变量声明，形参，函数声明的顺序与优先级?

填充变量的顺序：

函数形参 -> 函数声明 -> 变量声明
当变量声明遇到VO中已有同名时，不会影响已经存在的属性

函数形参：
由名称和对应值组成的一个变量对象的属性被创建
没有传对应参数的话，那么由名称和undefined组成的变量对象的属性会被创建

函数声明：
由名称和对应值（函数对象(function-object)）组成一个变量对象的属性会被创建
如果变量中已经有这个相同名称的属性，则完全替换

变量声明：
由名称和对应值（undefined）组成的一个变量对象的属性被创建
如果变量名称与已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的

## js引擎单线程机制

让你不再困惑进程与线程

首先，先区分一个概念：

- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）

- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

有一个很形象的描述：

```js
- 进程是一个工厂，系统会给它分配资源（独立的一块内存，进程之间相互独立）

- 线程是工厂中的工人，多个工人协作完成一个任务（多个线程在进程中执行）

- 工厂内不能没有工人（一个进程由一个或多个线程组成）

- 工人之间共享空间（同一进程下的各个线程之间共享程序的内存空间-包括代码段、数据集、堆等）
```

当然了，不同进程之间也可以通信，不过代价较大

再了解一点，现在通用的叫法：**单线程与多线程**，都是指**在一个进程内**的单和多。（所以核心还是得属于一个进程才行）

### 浏览器的进程与线程

浏览器是多进程的（譬如如果是windows电脑，可以在任务管理器中看到有多个进程id），拿`Blink`内核为例，它是多进程架构

__浏览器多线程的优点__

相比于单进程浏览器，多进程有如下优点：

- 避免单个page crash影响整个浏览器

- 避免第三方插件crash影响整个浏览器

- 多进程充分利用多核优势

- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

__譬如浏览器包含的**主要进程**如下：__（部分内容来自参考来源）

1. Browser进程：主进程，只有一个。作用有

    - 负责浏览器界面显示，与用户交互。如前进，后退等
    
    - 负责各个页面的管理，创建和销毁其他进程
    
    - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
    
    - 网络资源的管理，下载等
    
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

3. GPU进程：最多一个，用于3D绘制等

4. 浏览器内核进程（Renderer进程，多线程的）：默认每个页面一个进程，互不影响。主要作用为

    - 页面渲染，脚本执行，事件处理等
    
请注意，这些都是进程，进程是可以相互隔离的。

可以简单的理解为：在Chrome中打开一个网页相当于起了一个进程（进程内有自己的多线程）
    
__一个浏览器内核通常包括以下常驻线程：__

1. JS引擎线程

    - 负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程负责解析Javascript脚本，运行代码。
    
    - JS引擎是单线程的（或许是由于多线程的复杂性，因此最初设计时选择了单线程）
    
    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序

2. GUI渲染线程

    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。

    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行
    
    - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
    
3. 定时触发器线程

    - 传说中的`setInternal`
    
    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    
    - 因此通过单独线程来计时并触发定时
    
    - 所以为什么说`setInternal`和`setTimeout`会有区别

4. 事件触发线程

    - 当JavaScript引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中

    - 当对应的事件符合触发条件时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
    
    - 但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

5. 异步http请求线程

    - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
    
    - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。
  

__Browser进程和Renderer进程的通信过程__（部分内容来自参考来源，简化了部分）

- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后通过RendererHost接口转交给Renderer进程

- Renderer进程的Renderer接口收到消息，然后开始渲染

    - 浏览器内核进行HTML解析和DOM树构建，CSS解析，JS执行，RenderObject树构建，布局和绘制等过程，生成用户可见区域（ViewPort）的Bitmap
    
    - 最后通过共享内存方式IPC给Browser进程
    
- Browser进程使用Bitmap内存在界面上绘制出图像  
    
### GUI 渲染线程 与 JavaScript引擎线程互斥

由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，
GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

__JS阻塞页面加载__

由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。

因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。



webworker?

浏览器直接接管的线程（独立于JS线程之外），Worker接口号称会生成真正的操作系统级别的线程，因此无法去访问非线程安全的组件或者是 DOM。
需要通过序列化对象来与线程交互特定的数据。
～～

- 浏览器是多进程的（一个进程内可以有多个线程）-譬如包括浏览器进程，渲染器进程，插件进程（譬如windows中可以看到有多个进程id）

- JS引擎可以认为是占据浏览器中的一个进程，而且JS引擎是单线程的（即这个JS引擎占据的进程内只会开一个线程）


## js的event loop机制

首先，需知道js中的事件队列机制：

- js在遇到异步任务时（譬如setTimeout），会将这个异步任务（回调函数）推入**事件队列中**，然后继续执行自己的主线程任务

- 推入事件队列中的任务满足特定条件后（如设置的延时到期了），会将任务推入主线程中（多个异步则按照触发先后依次推入，排队执行），并在主线程空闲时（如果被占据则会先等待主线程执行）执行

然后，需要明确JS中有两种任务形式

- macro-task(宏任务)：包括整体代码script块，setTimeout，setInterval

- micro-task(微任务)：Promise，process.nextTick

js的执行机制是：

- 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里

- 当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完


##  js的内存回收机制

1.标记清除
主流浏览器实现的垃圾清除机制，最常用的垃圾回收方式

当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
而当变量离开环境时，则将其标记为“离开环境”。

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。
而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

2.引用计数
需要考虑循环引用问题

引用计数的含义是跟踪记录每个值被引用的次数。
当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
如果同一个值又被赋给另一个变量，则该值的引用次数加1。

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。
当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

但是需要考虑两个对象循环引用的问题，容易造成内存泄漏

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：
1）遍历所有可访问的对象。
2）回收已不可访问的对象。

GC的缺陷
和其他语言一样，javascript的GC策略也无法避免一个问题：
GC时，停止响应其他操作，这是为了安全考虑。
而Javascript的GC在100ms甚至以上，对一般的应用还好，
但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。
这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

GC优化策略
1.分代回收（Generation GC）
目的是通过区分“临时”与“持久”对象；
多回收“临时对象”区（young generation），
少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。

2.增量GC
这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。
这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。

比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。

像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）

## 最常见的两种攻击（XSS 和 CSRF）了解？

xss：
跨站脚本
说到底实际上是一个HTML注入问题
由于前端没有过滤输入，导致攻击者可以执行一些危险脚本
譬如输入文本实际为脚本执行代码，盗取cookie等敏感信息

主要的防御是：对输入进行限制


CSRF:
跨域伪造请求（XSS是csrf的诸多途径之一）
即冒充用户在站内操作
一般方法是通过 XSS 或链接欺骗等途径，让用户在本机(即拥有身份 cookie 的浏览器端)发起用户所不知道的请求。

要完成一次CSRF攻击，受害者必须依次完成两个步骤：
1.登录受信任网站A，并在本地生成Cookie。
2.在不登出A的情况下，访问危险网站B。

你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：
1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。
2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。
(事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……)
3.所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。


现在网站一般都会加上referer验证，可以防止一部分伪造
服务端一般三种策略：
1.验证HTTP Referer字段
2.在请求地址中添加token并验证
（譬如post中，以参数的形式加入一个随机产生的token）
3.在HTTP头中自定义属性并验证

